import {getuserbyid} from "../db/user.db.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import {formatError } from "../utils/errformatter.js";
import { createstudent,getstudentbyid,deletesudentbyid,updatestudentbyid,getallstudents } from "../db/student.db.js";   
import joi from "joi";
import { v2 as cloudinary } from "cloudinary";
import fs from "fs/promises";
import path from "path";
import { Console } from "console";
import { get } from "http";

// Full student schema (useful for responses / full validation), but create flow uses createStudentSchema below
const studentSchema = joi.object({
    id: joi.number().integer().required(),
    offical_email: joi.string()
        .pattern(/^[A-Za-z0-9._%+-]+@bmsit\.in$/)
        .required()
        .messages({
            'string.pattern.base': 'offical_email must be a valid @bmsit.in email',
            'string.empty': 'offical_email is required'
        }),
    personal_email: joi.string().email().required(),
    resume: joi.string().uri().required(),
    LeetCode: joi.string().uri().required(),
    HackerRank: joi.string().uri().required(),
    HackerEarth: joi.string().uri().required(),
    linkedin: joi.string().uri().required(),
    CGPA: joi.number().min(0).max(10).required(),
    created_at: joi.date().required(),
    phone_number: joi.string().pattern(/^[0-9]{10}$/).required()
});

// Schema for create requests (resume is uploaded separately and id/created_at are generated by DB)
const createStudentSchema = joi.object({
    offical_email: joi.string()
        .pattern(/^[A-Za-z0-9._%+-]+@bmsit\.in$/)
        .required()
        .messages({ 'string.pattern.base': 'offical_email must be a valid @bmsit.in email' }),
    // allow clients to send official_email (correct spelling) too; we'll normalize below
    official_email: joi.string().optional(),
    personal_email: joi.string().email().required(),
    LeetCode: joi.string().uri().required(),
    HackerRank: joi.string().uri().required(),
    HackerEarth: joi.string().uri().required(),
    linkedin: joi.string().uri().required(),
    CGPA: joi.number().min(0).max(10).required(),
    phone_number: joi.string().pattern(/^[0-9]{10}$/).required()
});

cloudinary.config({
    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET,
    secure: true
});

export const registerStudent = asyncHandler(async (req, res) => {
    let student_resume;
    console.log("Register Student Called");
    // allow id from params, or from multipart form-data (user_id), or from authenticated user
    const normalizedForm = normalizeStudentForm(req.body);
    const studentid = req.params.id || normalizedForm.user_id || req.user?.id;
    console.log("Student ID:", studentid);
    // verify user existence and role
    const verifyStudent = await getuserbyid(studentid);
    console.log("verifyStudent", verifyStudent);
    if (!verifyStudent) {
        return res.status(404).json({ route: req.originalUrl, success: false, message: 'user does not exist' });
    }
    if (verifyStudent.role_id !== 13) {
        return res.status(403).json({ route: req.originalUrl, success: false, message: 'user is not allowed to register as student' });
    }

    // Normalize and validate body first to avoid uploading if invalid
    // stripUnknown: true removes extra fields (for example if form-data contains an `id` field)
    const { error: validationError, value: validatedBody } = createStudentSchema.validate(normalizedForm, { abortEarly: false, stripUnknown: true });
    if (validationError) {
        return res.status(422).json({ route: req.originalUrl, success: false, errors: validationError.details.map(d => d.message) });
    }

    // Ensure file exists and is acceptable
    if (!req.file || !req.file.path) {
        return res.status(400).json({ route: req.originalUrl, success: false, message: 'resume file is required' });
    }
    const allowedMimes = ['application/pdf'];
    if (req.file.mimetype && !allowedMimes.includes(req.file.mimetype)) {
        return res.status(415).json({ route: req.originalUrl, success: false, message: 'Only PDF resumes are allowed' });
    }

    try {
        // Upload resume to Cloudinary. For PDFs use resource_type: 'raw'
        const uploadResume = await cloudinary.uploader.upload(req.file.path, {
            folder: 'student_resumes',
            use_filename: true,
            unique_filename: true,
            resource_type: 'raw'
        });
        student_resume = uploadResume.secure_url;
    } catch (error) {
        console.error('Error uploading resume to Cloudinary:', error);
        throw formatError('Failed to upload resume');
    } finally {
        // Always attempt to clean up the local file once (if present)
        try { if (req.file && req.file.path) await fs.unlink(path.resolve(req.file.path)); } catch (_) {}
    }

    // Normalize email field name: accept `official_email` from client
    const offical_email = validatedBody.offical_email || validatedBody.official_email;
    const { personal_email, LeetCode, HackerRank, HackerEarth, linkedin, CGPA, phone_number } = validatedBody;

    const newStudent = {
        offical_email,
        personal_email,
        LeetCode,
        HackerRank,
        HackerEarth,
        linkedin,
        CGPA,
        phone_number,
        resume: student_resume,
        id: studentid,
        created_at: new Date()
    };

    try {
        console.log("newStudent", newStudent);
        const created = await createstudent(newStudent);
        console.log("created", created);
        return res.status(201).json({ route: req.originalUrl, success: true, message: 'Student registered successfully', student: created });
    } catch (dbErr) {
        console.error('DB error creating student:', dbErr);
        // If formatError maps DB errors nicely, use it; otherwise return generic
        throw formatError('Failed to create student');
    }
});

// Helper to extract Cloudinary public_id from a resume URL
function extractCloudinaryPublicId(url) {
    try {
        if (!url) return null;
        const u = new URL(url);
        // path after /upload/ (or /raw/upload/)
        const uploadIndex = u.pathname.indexOf('/upload/');
        if (uploadIndex === -1) return null;
        let afterUpload = u.pathname.slice(uploadIndex + '/upload/'.length);
        // remove version prefix like v123456789/
        afterUpload = afterUpload.replace(/^v\d+\//, '');
        // remove file extension
        const lastDot = afterUpload.lastIndexOf('.');
        if (lastDot !== -1) afterUpload = afterUpload.slice(0, lastDot);
        // remove leading slash if present
        if (afterUpload.startsWith('/')) afterUpload = afterUpload.slice(1);
        return afterUpload;
    } catch (err) {
        console.error('Error extracting public id from url', err, url);
        return null;
    }
}

// Normalize various incoming form field names to the canonical keys used by the service
function normalizeStudentForm(body) {
    if (!body || typeof body !== 'object') return {};
    return {
        // accept both misspelled and correctly spelled variants
        offical_email: body.offical_email || body.official_email || body.officialEmail || body['official email'] || null,
        personal_email: body.personal_email || body.personalEmail || body['personal email'] || null,
        // various casing possibilities for these fields
        LeetCode: body.LeetCode || body.leetCode || body.leetcode || null,
        HackerRank: body.HackerRank || body.hackerrank || body.HackerRank || null,
        HackerEarth: body.HackerEarth || body.hackerearth || body.HackerEarth || null,
        linkedin: body.linkedin || body.LinkedIn || body.linkedIn || null,
        CGPA: body.CGPA !== undefined ? body.CGPA : (body.cgpa !== undefined ? body.cgpa : null),
        phone_number: body.phone_number || body.phoneNumber || body['phone number'] || null,
        // allow client to send id as user_id in form-data
        user_id: body.user_id || body.userId || body.id || null
    };
}

export const updateStudent = asyncHandler(async (req, res) => {
    const normalizedForm = normalizeStudentForm(req.body);
    const studentid = req.params.id || normalizedForm.user_id || req.user?.id;
    if (!studentid) return res.status(400).json({ success: false, message: 'student id required' });

    const existing = await getstudentbyid(studentid);
    if (!existing) return res.status(404).json({ success: false, message: 'student not found' });

    // Normalize and validate body (allow unknowns to be stripped)
    const { error: validationError, value: validatedBody } = createStudentSchema.validate(normalizedForm, { abortEarly: false, stripUnknown: true });
    if (validationError) return res.status(422).json({ success: false, errors: validationError.details.map(d => d.message) });

    // If a new resume is provided, upload and delete old one
    let newResumeUrl = existing.resume;
    if (req.file && req.file.path) {
        const allowedMimes = ['application/pdf'];
        if (req.file.mimetype && !allowedMimes.includes(req.file.mimetype)) {
            return res.status(415).json({ success: false, message: 'Only PDF resumes are allowed' });
        }
        try {
            const upload = await cloudinary.uploader.upload(req.file.path, {
                folder: 'student_resumes',
                use_filename: true,
                unique_filename: true,
                resource_type: 'raw'
            });
            newResumeUrl = upload.secure_url;
        } catch (err) {
            console.error('Error uploading new resume:', err);
            try { if (req.file && req.file.path) await fs.unlink(path.resolve(req.file.path)); } catch(_){}
            return res.status(500).json({ success: false, message: 'Failed to upload new resume' });
        } finally {
            try { if (req.file && req.file.path) await fs.unlink(path.resolve(req.file.path)); } catch(_){}
        }

        // delete old resume if it exists
        if (existing.resume) {
            const publicId = extractCloudinaryPublicId(existing.resume);
            if (publicId) {
                try {
                    await cloudinary.uploader.destroy(publicId, { resource_type: 'raw' });
                } catch (delErr) {
                    console.error('Failed to delete old resume from Cloudinary', delErr);
                    // don't fail the whole request because of deletion failure
                }
            }
        }
    }

    // prepare update payload - keep created_at unchanged
    const offical_email = validatedBody.offical_email || validatedBody.official_email || existing.offical_email;
    const personal_email = validatedBody.personal_email || existing.personal_email;
    const LeetCode = validatedBody.LeetCode || existing.LeetCode;
    const HackerRank = validatedBody.HackerRank || existing.HackerRank;
    const HackerEarth = validatedBody.HackerEarth || existing.HackerEarth;
    const linkedin = validatedBody.linkedin || existing.linkedin;
    const CGPA = validatedBody.CGPA !== undefined ? validatedBody.CGPA : existing.CGPA;
    const phone_number = validatedBody.phone_number || existing.phone_number;

    const updateData = {
        offical_email,
        personal_email,
        resume: newResumeUrl,
        LeetCode,
        HackerRank,
        HackerEarth,
        linkedin,
        CGPA,
        created_at: existing.created_at,
        phone_number
    };

    try {
        const result = await updatestudentbyid(studentid, updateData);
        return res.status(200).json({ success: true, student: result.student });
    } catch (err) {
        console.error('DB error updating student:', err);
        return res.status(500).json({ success: false, message: 'Failed to update student' });
    }
});

export const getAllStudents = asyncHandler(async (req, res) => {
    try {
        const students = await getallstudents();
        return res.status(200).json({ success: true, students });
    } catch (err) {
        console.error('DB error fetching students:', err);
        return res.status(500).json({ success: false, message: 'Failed to fetch students' });
    }
});

export const deleteStudent = asyncHandler(async (req, res) => {
    const studentid = req.params.id || req.user?.id;
    if (!studentid) return res.status(400).json({ success: false, message: 'student id required' });

    const existing = await getstudentbyid(studentid);
    if (!existing) return res.status(404).json({ success: false, message: 'student not found' });

    // delete resume from Cloudinary if present
    if (existing.resume) {
        const publicId = extractCloudinaryPublicId(existing.resume);
        if (publicId) {
            try {
                await cloudinary.uploader.destroy(publicId, { resource_type: 'raw' });
            } catch (delErr) {
                console.error('Failed to delete resume from Cloudinary during student delete', delErr);
                // continue; don't block deletion because of Cloudinary delete failure
            }
        }
    }

    try {
        const deleted = await deletesudentbyid(studentid);
        if (deleted) return res.status(200).json({ success: true, message: 'Student deleted' });
        return res.status(500).json({ success: false, message: 'Failed to delete student' });
    } catch (err) {
        console.error('DB error deleting student:', err);
        return res.status(500).json({ success: false, message: 'Failed to delete student' });
    }
});

export const getstudentbyidcontroller = asyncHandler(async (req, res) => {
    const studentid = req.params.id || req.user?.id;
    if (!studentid) return res.status(400).json({ success: false, message: 'student id required' });

    try {
        const student = await getstudentbyid(studentid);
        if (!student) return res.status(404).json({ success: false, message: 'student not found' });
        return res.status(200).json({ success: true, student });
    } catch (err) {
        console.error('DB error fetching student:', err);
        return res.status(500).json({ success: false, message: 'Failed to fetch student' });
    }
});

export default { registerStudent, updateStudent, getAllStudents, deleteStudent,getstudentbyidcontroller };